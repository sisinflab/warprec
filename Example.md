# Recommendation Module

Our development and product teams have worked to deliver a first version of the Recommendation Engine product based on WarpRec. The product has been implemented following a microservices architecture and uses Terraform for infrastructure management on Google Cloud Platform. It consists of five core microservices:
- Recommendation Engine
- Authentication API
- Recommendation Data Ingestion
- Recommendation Trainer
- Triton Inference Server

Specifically, "Triton Inference Server" has not yet been implemented, while the first four microservices have been implemented and are currently under testing. Early testing has surfaced significant issues rooted in poor initial design and the time pressure to ship a first version quickly. These include problems with scalability, data management, logically broken flows, non-standard API controllers, and a wide range of mistakes typically made by junior developers. From a functional standpoint the product arguably covers the intended feature set, but from a technical standpoint a full refactor of both the code and the architecture is required to meet the quality, scalability, and maintainability goals. In particular, the microservice architecture, their operational flows, and the inter-service communication contracts all need to be revisited.

Therefore, acting as a Senior Software Engineer, Senior Cloud Architect, and seasoned code reviewer, you are asked to addresses the following points:
1. Deeply analyze and reason the current code and architecture of the following microservices — Recommendation Engine, Authentication API, Recommendation Data Ingestion, and Recommendation Trainer — and identify every technical and design issue that emerges from a thorough review of the existing codebase and architecture. Also detect inconsistencies of any kind, including but not limited to: design flaws, anti-patterns, code smells, scalability issues, maintainability issues, security issues, and any other technical debt. Document all findings in a folder at the root of this project named `Code Review Findings`, with one Markdown file per microservice listing all the issues detected and their detailed explanation. Furthermore, for each issue detected, provide a detailed recommendation on how to address it.
2. Extract every single feature in full detail, omitting nothing — including the most minor implementation specifics — and identify which features have been correctly implemented, which are missing, and which have been implemented incorrectly or incompletely. Document all features in a folder at the root of this project named `Recommendation Engine Functionalities & Technical Details`, with one Markdown file per microservice listing all the features required and alongside this information provide also all possible PlantUML diagrams considering ER diagram, Class-Objects diagram, Component diagram, Sequence diagram, and Activity diagram.
3. Using those features as the sole source of truth, discard everything that has been implemented so far and design a new software architecture for all microservices. Create a new branch named `refactor` in each affected repository (`services/recsys-auth-service`, `services/recsys-train-inference-service`, `services/recsys-ingestion-service`). Provide also a modified version of all possible PlantUML diagrams considering ER diagram, Class-Objects diagram, Component diagram, Sequence diagram, and Activity diagram.
4. Starting from the newly created software architecture, implement the new codebase for all microservices, adhering to the highest standards of code quality and best practices mentioned in section "Code Quality and Best Practices" below. A strict requirement is to use Python 3.12 and Polars.

Important: We need to address each point sequentially, and I have to manually verify that each point has been fully addressed before moving on to the next one. Most importantly, during the design phase it's mandatory to self-ask critical questions and review the design choices to consider multiple alternatives, in order to select the best possible design decition.

During the review phase, be brutal and direct. Throughout every phase of this process it is critical that you strictly follow the **Code Quality and Best Practices** section below, in order to ensure the final product is of the highest quality and production-ready.

## Code Quality and Best Practices
The project must be production-ready and must implement all guidelines and best practices for writing clean, maintainable, and scalable code. The project structure must be modular, with a clear separation between the various components. The code must be well documented, with docstrings for all functions and classes, and explanatory comments where necessary. The software components needs to be implemented using OOP programming paradigm. The project must be containerized using Docker, with a well-defined Dockerfile (create multiple Dockefile, e.g. if CPU and GPU environment should be considered) that follows best practices for security and efficiency (hardened images, multi-stage builds, etc.). The system must be designed to be scalable and resilient, with clear error and failure handling. Implement a complete test suite, covering unit tests, integration tests, ablation tests, system tests (if applicable) using a testing framework. All the tests should be run in a Docker image. The project should be tested locally for development purposes. Write a Makefile to automate the build, test, and deployment processes. Finally, add a comprihensive GitHub-ready README file covering all aspects of the project. Finally, verify that all tests pass.
